<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Synthwave Beat Generator</title>
<style>
body { background: linear-gradient(135deg, #1a0a2e 0%, #2d1b4e 100%); color: #ff6ec7; font-family: 'Courier New', monospace; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; margin: 0; }
h1 { font-size: 2.5em; text-shadow: 0 0 20px #ff6ec7, 0 0 40px #ff6ec7; margin-bottom: 10px; }
.subtitle { color: #7b68ee; margin-bottom: 30px; }
button { background: linear-gradient(180deg, #ff6ec7 0%, #d64fa0 100%); color: #1a0a2e; border: none; padding: 15px 40px; font-size: 1.2em; font-family: inherit; font-weight: bold; cursor: pointer; margin: 10px; border-radius: 4px; box-shadow: 0 0 20px rgba(255,110,199,0.5); transition: all 0.2s; }
button:hover { background: linear-gradient(180deg, #ff9ed2 0%, #ff6ec7 100%); transform: scale(1.05); }
button:disabled { opacity: 0.5; cursor: default; transform: none; }
#status { margin-top: 20px; font-size: 0.9em; color: #7b68ee; min-height: 24px; }
.info { color: #9370db; font-size: 0.8em; margin-top: 40px; text-align: center; line-height: 1.6; }
</style>
</head>
<body>
<h1>âš¡ SYNTHWAVE BEAT âš¡</h1>
<div class="subtitle">120 BPM â€¢ 16 Bars â€¢ Pure 80s</div>
<div>
<button id="playBtn" onclick="togglePlay()">â–¶ PLAY</button>
<button id="exportBtn" onclick="exportWAV()">ðŸ’¾ EXPORT WAV</button>
</div>
<div id="status"></div>
<div class="info">
Kick â€¢ Snare â€¢ Hi-Hats â€¢ Bass â€¢ Pad â€¢ Arpeggio<br>
Built with Web Audio API â€” No external dependencies
</div>
<script>
const BPM = 120;
const BEAT = 60 / BPM;
const BARS = 16;
const DURATION = BARS * 4 * BEAT;

let actx = null;
let playing = false;
let stopTime = 0;

function status(msg) { document.getElementById('status').textContent = msg; }

function createBeat(ctx, dest, startTime) {
  const master = ctx.createGain();
  master.gain.value = 0.7;
  master.connect(dest);

  // --- KICK DRUM ---
  for (let bar = 0; bar < BARS; bar++) {
    for (let b = 0; b < 4; b++) {
      const t = startTime + (bar * 4 + b) * BEAT;
      const osc = ctx.createOscillator();
      const g = ctx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, t);
      osc.frequency.exponentialRampToValueAtTime(30, t + 0.15);
      g.gain.setValueAtTime(0.8, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
      osc.connect(g);
      g.connect(master);
      osc.start(t);
      osc.stop(t + 0.3);
    }
  }

  // --- SNARE (noise burst + body) ---
  const snareLen = Math.floor(ctx.sampleRate * 0.2);
  const snareBuffer = ctx.createBuffer(1, snareLen, ctx.sampleRate);
  const sd = snareBuffer.getChannelData(0);
  for (let i = 0; i < sd.length; i++) {
    sd[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / sd.length, 3);
  }
  
  for (let bar = 0; bar < BARS; bar++) {
    for (let b of [1, 3]) {
      const t = startTime + (bar * 4 + b) * BEAT;
      // Noise part
      const src = ctx.createBufferSource();
      src.buffer = snareBuffer;
      const hp = ctx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 2000;
      const g = ctx.createGain();
      g.gain.setValueAtTime(0.6, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
      src.connect(hp);
      hp.connect(g);
      g.connect(master);
      src.start(t);
      // Body
      const osc = ctx.createOscillator();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(200, t);
      osc.frequency.exponentialRampToValueAtTime(80, t + 0.1);
      const og = ctx.createGain();
      og.gain.setValueAtTime(0.4, t);
      og.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
      osc.connect(og);
      og.connect(master);
      osc.start(t);
      osc.stop(t + 0.15);
    }
  }

  // --- HI-HATS ---
  const hhLen = Math.floor(ctx.sampleRate * 0.05);
  const hhBuffer = ctx.createBuffer(1, hhLen, ctx.sampleRate);
  const hd = hhBuffer.getChannelData(0);
  for (let i = 0; i < hd.length; i++) {
    hd[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / hd.length, 10);
  }

  for (let bar = 0; bar < BARS; bar++) {
    for (let e = 0; e < 8; e++) {
      const t = startTime + (bar * 4 + e * 0.5) * BEAT;
      const src = ctx.createBufferSource();
      src.buffer = hhBuffer;
      const hp = ctx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 8000;
      const g = ctx.createGain();
      g.gain.setValueAtTime(e % 2 === 0 ? 0.25 : 0.12, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.04);
      src.connect(hp);
      hp.connect(g);
      g.connect(master);
      src.start(t);
    }
  }

  // --- BASS (sawtooth with filter sweep) ---
  // Am progression: A2, A2, C3, C3, D3, D3, E3, E3 (2 bars each)
  const bassNotes = [55, 55, 65.41, 65.41, 73.42, 73.42, 82.41, 82.41];
  for (let bar = 0; bar < BARS; bar++) {
    const noteIdx = Math.floor(bar / 2) % bassNotes.length;
    const freq = bassNotes[noteIdx];
    
    for (let b = 0; b < 4; b++) {
      const t = startTime + (bar * 4 + b) * BEAT;
      const osc = ctx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.value = freq;
      
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.Q.value = 5;
      filter.frequency.setValueAtTime(200, t);
      filter.frequency.exponentialRampToValueAtTime(800, t + BEAT * 0.3);
      filter.frequency.exponentialRampToValueAtTime(200, t + BEAT * 0.9);
      
      const g = ctx.createGain();
      g.gain.setValueAtTime(0.3, t);
      g.gain.setValueAtTime(0.3, t + BEAT * 0.8);
      g.gain.exponentialRampToValueAtTime(0.001, t + BEAT * 0.95);
      
      osc.connect(filter);
      filter.connect(g);
      g.connect(master);
      osc.start(t);
      osc.stop(t + BEAT);
    }
  }

  // --- PAD (detuned saws) ---
  // Chord progression: Am, C, Dm, Em (4 bars each)
  const chords = [
    [220, 261.63, 329.63],    // Am: A3, C4, E4
    [261.63, 329.63, 392],    // C: C4, E4, G4
    [293.66, 349.23, 440],    // Dm: D4, F4, A4
    [329.63, 392, 493.88]     // Em: E4, G4, B4
  ];
  
  for (let section = 0; section < 4; section++) {
    const chord = chords[section];
    const sectionStart = startTime + section * 4 * 4 * BEAT;
    const sectionEnd = sectionStart + 4 * 4 * BEAT;
    
    for (let note of chord) {
      for (let detune of [-10, 0, 10]) {
        const osc = ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = note;
        osc.detune.value = detune;
        
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1500;
        filter.Q.value = 1;
        
        const g = ctx.createGain();
        g.gain.setValueAtTime(0, sectionStart);
        g.gain.linearRampToValueAtTime(0.06, sectionStart + 0.5);
        g.gain.setValueAtTime(0.06, sectionEnd - 0.5);
        g.gain.linearRampToValueAtTime(0, sectionEnd);
        
        osc.connect(filter);
        filter.connect(g);
        g.connect(master);
        osc.start(sectionStart);
        osc.stop(sectionEnd + 0.1);
      }
    }
  }

  // --- ARPEGGIO (square wave, classic 80s pattern) ---
  // 16th note arpeggios
  const arpNotes = [
    [220, 261.63, 329.63, 440],      // Am
    [261.63, 329.63, 392, 523.25],   // C
    [293.66, 349.23, 440, 587.33],   // Dm
    [329.63, 392, 493.88, 659.25]    // Em
  ];
  
  for (let bar = 0; bar < BARS; bar++) {
    const chordIdx = Math.floor(bar / 4) % 4;
    const notes = arpNotes[chordIdx];
    
    for (let sixteenth = 0; sixteenth < 16; sixteenth++) {
      const t = startTime + (bar * 4 * BEAT) + (sixteenth * BEAT / 4);
      // Up-down pattern
      let noteIdx;
      const pos = sixteenth % 8;
      if (pos < 4) noteIdx = pos;
      else noteIdx = 7 - pos;
      
      const osc = ctx.createOscillator();
      osc.type = 'square';
      osc.frequency.value = notes[noteIdx];
      
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 2000;
      
      const g = ctx.createGain();
      g.gain.setValueAtTime(0.08, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + BEAT / 4 - 0.01);
      
      osc.connect(filter);
      filter.connect(g);
      g.connect(master);
      osc.start(t);
      osc.stop(t + BEAT / 4);
    }
  }

  return master;
}

function togglePlay() {
  if (!actx) actx = new (window.AudioContext || window.webkitAudioContext)();
  
  if (playing) {
    actx.close();
    actx = null;
    playing = false;
    document.getElementById('playBtn').textContent = 'â–¶ PLAY';
    status('Stopped');
    return;
  }
  
  actx = new (window.AudioContext || window.webkitAudioContext)();
  createBeat(actx, actx.destination, actx.currentTime + 0.1);
  playing = true;
  stopTime = actx.currentTime + DURATION + 0.2;
  document.getElementById('playBtn').textContent = 'â¹ STOP';
  status('Playing...');
  
  // Auto-stop when done
  setTimeout(() => {
    if (playing && actx && actx.currentTime >= stopTime - 0.5) {
      playing = false;
      document.getElementById('playBtn').textContent = 'â–¶ PLAY';
      status('Finished');
    }
  }, (DURATION + 0.5) * 1000);
}

async function exportWAV() {
  status('Rendering audio...');
  document.getElementById('exportBtn').disabled = true;
  
  // Create offline context for rendering
  const sampleRate = 44100;
  const length = Math.ceil(DURATION * sampleRate) + sampleRate; // +1 sec buffer
  const offlineCtx = new OfflineAudioContext(2, length, sampleRate);
  
  createBeat(offlineCtx, offlineCtx.destination, 0);
  
  const rendered = await offlineCtx.startRendering();
  status('Encoding WAV...');
  
  // Convert to WAV
  const numCh = rendered.numberOfChannels;
  const wavLength = length * numCh * 2 + 44;
  const buffer = new ArrayBuffer(wavLength);
  const view = new DataView(buffer);
  
  // WAV header
  const writeString = (offset, str) => {
    for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
  };
  writeString(0, 'RIFF');
  view.setUint32(4, wavLength - 8, true);
  writeString(8, 'WAVE');
  writeString(12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numCh, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * numCh * 2, true);
  view.setUint16(32, numCh * 2, true);
  view.setUint16(34, 16, true);
  writeString(36, 'data');
  view.setUint32(40, length * numCh * 2, true);
  
  // Write samples
  const channels = [];
  for (let c = 0; c < numCh; c++) channels.push(rendered.getChannelData(c));
  
  let offset = 44;
  for (let i = 0; i < length; i++) {
    for (let c = 0; c < numCh; c++) {
      const s = Math.max(-1, Math.min(1, channels[c][i] || 0));
      view.setInt16(offset, s * 0x7FFF, true);
      offset += 2;
    }
  }
  
  // Download
  const blob = new Blob([buffer], { type: 'audio/wav' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'synthwave-beat-120bpm.wav';
  a.click();
  URL.revokeObjectURL(url);
  
  document.getElementById('exportBtn').disabled = false;
  status('âœ… Exported! Check your downloads.');
}
</script>
</body>
</html>
